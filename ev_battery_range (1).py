# -*- coding: utf-8 -*-
"""ev battery range.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1L9Ql_Z83DV4viwGQRaqO6RZNXw8zoO7H
"""

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
from numpy import asarray
from sklearn.preprocessing import OrdinalEncoder
from sklearn.model_selection import train_test_split

ev = pd.read_csv(r'C:\Users\Dell\EV_Project\NewElectricCarData (1).csv')
ev.head()

ev.columns

ev.info()

ev.shape

#Check missing value
ev.isnull().sum()

ev.dtypes

ev.nunique()

ev.describe()

#Analysis range by EV Brand
ax= plt.figure(figsize=(20,5))
sns.barplot(x='Brand',y='Range_Km',data=ev,palette='hls')
plt.grid(axis='y')
plt.title('Electric Vehicle Range VS EV Brand')
plt.xlabel('Brand')
plt.ylabel('Range per Km')
plt.xticks(rotation=45)

# Model with highest Range
range_df = ev.sort_values(by=['Range_Km'], ascending=False)
range_df[['Brand','Model','Range_Km']].head(n=1)

#Analysis acceleration by EV Brand
ax= plt.figure(figsize=(20,5))
sns.barplot(x='Brand',y='AccelSec',data=ev,palette='coolwarm')
plt.grid(axis='y')
plt.title('Electric Vehicle Acceleration VS EV Brand')
plt.xlabel('Brand')
plt.ylabel('AccelSec')
plt.xticks(rotation=45)

# Model with the shortest Acceleration time
df = ev.sort_values(by=['AccelSec'], ascending=True)
df[['Brand','Model','AccelSec']].head(n=1)

#Analysis top speed by EV Brand
ax= plt.figure(figsize=(20,5))
sns.barplot(x='Brand',y='TopSpeed_KmH',data=ev,palette='husl')
plt.grid(axis='y')
plt.title('Electric Vehicle Top Speed VS EV Brand')
plt.xlabel('Brand')
plt.ylabel('TopSpeed_KmH')
plt.xticks(rotation=45)

# Model with Top Speed
speed_df = ev.sort_values(by=['TopSpeed_KmH'], ascending=False)
speed_df[['Brand','Model','TopSpeed_KmH']].head(n=1)

#Analysis efficiency by EV Brand
ax= plt.figure(figsize=(20,5))
sns.barplot(x='Brand',y='Efficiency_WhKm',data=ev,palette='Paired')
plt.grid(axis='y')
plt.title('Electric Vehicle efficiency VS EV Brand')
plt.xlabel('Brand')
plt.ylabel('Efficiency_WhKm')
plt.xticks(rotation=45)

# Model with maximum Efficiency
eff_df = ev.sort_values(by=['Efficiency_WhKm'], ascending=False)
eff_df[['Brand','Model','Efficiency_WhKm']].head(n=1)

# Command-line Interface for Battery Range Prediction
print("Electric Vehicle Battery Range Prediction")

# Input fields for user data
top_speed = float(input("Enter Top Speed (Km/h): "))
acceleration = float(input("Enter Acceleration (Sec): "))
efficiency = float(input("Enter Efficiency (Wh/km): "))
seats = int(input("Enter Number of Seats: "))
brand = input(f"Enter Brand (options: {', '.join(ev['Brand'].unique())}): ")
power_train = input(f"Enter Power Train (options: {', '.join(ev['PowerTrain'].unique())}): ")
body_style = input(f"Enter Body Style (options: {', '.join(ev['BodyStyle'].unique())}): ")
segment = input(f"Enter Segment (options: {', '.join(ev['Segment'].unique())}): ")
soc_percentage = float(input("Enter State of Charge (%): "))

new_data = np.array([[top_speed, acceleration, efficiency, seats, brand, power_train, body_style, segment]])
# Encode categorical variables
new_data_encoded = encoder.transform(new_data[:, 4:]).toarray()  # Assuming brand, power_train, body_style, segment are at indices 4 to 7
new_data_final = np.concatenate((new_data[:, :4], new_data_encoded), axis=1)
predicted_range = predict_range(new_data_final)
remaining_range = predict_remaining_range(new_data_final, soc_percentage)
print(f"Predicted Battery Range: {predicted_range:.2f} km")
print(f"Remaining Battery Range at {soc_percentage}% SoC: {remaining_range:.2f} km")

# Encoding categorical data
ev.columns

ev1 = ev[['Brand', 'Model', 'PowerTrain', 'RapidCharge', 'PlugType', 'BodyStyle', 'Segment']]

print(ev1)

# define ordinal encoding
encoder = OrdinalEncoder()

# transform data
result = encoder.fit_transform(ev1)
print(result)

temp = ['Brand', 'Model', 'PowerTrain', 'RapidCharge', 'PlugType', 'BodyStyle', 'Segment']

ev.drop(temp,axis=1,inplace=True)

result = pd.DataFrame(result)

result.columns=["Brand", "Model", "PowerTrain", 'RapidCharge', "PlugType", "BodyStyle", "Segment"]
result.index+=1

result

ev1 = ev
ev1.index+=1

ev1[['Brand', 'Model', 'PowerTrain', 'RapidCharge', 'PlugType', 'BodyStyle', 'Segment']] = result[['Brand', 'Model', 'PowerTrain', 'RapidCharge', 'PlugType', 'BodyStyle', 'Segment']]
ev

#  Feature Selection
# #Define the target value(dependant variable) as y
X = ev['TopSpeed_KmH'].values.reshape(-1,1)
y = ev['Range_Km']

#Training and Test Data

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.2, random_state = 42)

## Check Shape, Sample of Test Train Data
print("X_train : ",X_train.shape)

print("X_test : ",X_test.shape)

print("y_train : ",y_train.shape)

print("y_test : ",y_test.shape)

# Import required libraries
import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense, Dropout
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import mean_squared_error, r2_score
import numpy as np

# Let's use more features for better prediction
features = ['TopSpeed_KmH', 'AccelSec', 'Efficiency_WhKm', 'Seats',
           'Brand', 'PowerTrain', 'BodyStyle', 'Segment']

# Prepare the data
X = ev[features].values
y = ev['Range_Km'].values

# Split the data
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Scale the features
scaler = StandardScaler()
X_train_scaled = scaler.fit_transform(X_train)
X_test_scaled = scaler.transform(X_test)

# Create the deep learning model
model = Sequential([
    Dense(64, activation='relu', input_shape=(len(features),)),
    Dropout(0.2),
    Dense(32, activation='relu'),
    Dropout(0.2),
    Dense(16, activation='relu'),
    Dense(1)
])

# Compile the model
model.compile(optimizer='adam', loss='mse', metrics=['mae'])

# Train the model
history = model.fit(
    X_train_scaled,
    y_train,
    validation_split=0.2,
    epochs=100,
    batch_size=32,
    verbose=1
)

# Make predictions
y_pred = model.predict(X_test_scaled)

# Evaluate the model
mse = mean_squared_error(y_test, y_pred)
r2 = r2_score(y_test, y_pred)

print(f'Mean Squared Error: {mse:.2f}')
print(f'R-squared Score: {r2:.2f}')

# Visualize the training history
plt.figure(figsize=(12, 4))

plt.subplot(1, 2, 1)
plt.plot(history.history['loss'], label='Training Loss')
plt.plot(history.history['val_loss'], label='Validation Loss')
plt.title('Model Loss')
plt.xlabel('Epoch')
plt.ylabel('Loss')
plt.legend()

plt.subplot(1, 2, 2)
plt.scatter(y_test, y_pred)
plt.plot([y_test.min(), y_test.max()], [y_test.min(), y_test.max()], 'r--', lw=2)
plt.xlabel('Actual Range (km)')
plt.ylabel('Predicted Range (km)')
plt.title('Actual vs Predicted Range')

plt.tight_layout()
plt.show()

# Function to make new predictions
def predict_range(new_data):
    # Scale the new data
    new_data_scaled = scaler.transform(new_data)
    # Make prediction
    prediction = model.predict(new_data_scaled)
    return prediction[0][0]

# Ensure scaler is fitted with feature names
scaler.fit(X_train)  # Fit scaler on training data with feature names

# Example dataset for multiple cars
new_data = pd.DataFrame([
    [200, 6.5, 150, 5, 1, 0, 0, 1],  # Car 1 data
    [180, 7.0, 140, 4, 0, 1, 1, 0],  # Car 2 data
    [220, 5.5, 160, 5, 0, 0, 1, 0]   # Car 3 data
], columns=[
    'TopSpeed_KmH', 'AccelSec', 'Efficiency_WhKm', 'Seats',
    'Brand', 'PowerTrain', 'BodyStyle', 'Segment'
])

# Scale the new data
new_data_scaled = scaler.transform(new_data)

# Predict battery range for each car
predicted_ranges = model.predict(new_data_scaled)

# Print the predicted range for each car
print("Predicted Battery Range for Each Car:")
for i, range_km in enumerate(predicted_ranges.flatten(), start=1):
    print(f"Car {i}: {range_km:.2f} km")

# Import required libraries
import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense, Dropout
from sklearn.metrics import mean_squared_error, r2_score
import matplotlib.pyplot as plt

# Define the predict_remaining_range function
def predict_remaining_range(new_data_scaled, soc_percentage):
    """
    Predict remaining range based on scaled input and state of charge.

    :param new_data_scaled: Scaled features of the vehicle
    :param soc_percentage: State of charge in percentage (0 to 100)
    :return: Predicted remaining range in km
    """
    # Predict the total range using the model
    total_range_km = model.predict(new_data_scaled, verbose=0)[0][0]

    # Calculate the remaining range based on SoC
    remaining_range_km = (total_range_km * soc_percentage) / 100.0

    return remaining_range_km

# Fit the scaler using the training data
scaler = StandardScaler()
X_train_scaled = scaler.fit_transform(pd.DataFrame(X_train, columns=features))
X_test_scaled = scaler.transform(pd.DataFrame(X_test, columns=features))

# Example SoC percentage (state of charge)
soc_percentage = 80  # Assume 80% charge for all vehicles

# Predict remaining range for all vehicles in the test dataset
predicted_remaining_ranges = []
for i in range(X_test_scaled.shape[0]):
    vehicle_data = X_test_scaled[i].reshape(1, -1)  # Reshape for prediction
    remaining_range = predict_remaining_range(vehicle_data, soc_percentage)
    predicted_remaining_ranges.append(remaining_range)

# Print predicted remaining ranges for each vehicle
print("Predicted Remaining Battery Range for Each Vehicle:")
for idx, range_km in enumerate(predicted_remaining_ranges, start=1):
    print(f"Vehicle {idx}: {range_km:.2f} km")



def calculate_remaining_range(battery_capacity_kwh, soc_percentage, energy_consumption_wh_per_km):
    """
    Calculate the remaining range of an EV based on charge and efficiency.

    :param battery_capacity_kwh: Total battery capacity in kWh
    :param soc_percentage: State of charge in percentage (0 to 100)
    :param energy_consumption_wh_per_km: Energy consumption in Wh/km
    :return: Remaining range in km
    """
    # Convert energy consumption to kWh/km
    energy_consumption_kwh_per_km = energy_consumption_wh_per_km / 1000.0

    # Calculate the remaining battery capacity
    remaining_capacity_kwh = (battery_capacity_kwh * soc_percentage) / 100.0

    # Calculate the remaining range
    remaining_range_km = remaining_capacity_kwh / energy_consumption_kwh_per_km

    return remaining_range_km

# Example data for multiple vehicles
vehicles = [
    {"battery_capacity": 75, "soc": 60, "energy_consumption": 200},  # Vehicle 1
    {"battery_capacity": 50, "soc": 80, "energy_consumption": 180},  # Vehicle 2
    {"battery_capacity": 100, "soc": 50, "energy_consumption": 250},  # Vehicle 3
]

# Calculate remaining range for each vehicle
print("Remaining Range for Each Vehicle:")
for i, vehicle in enumerate(vehicles, 1):
    remaining_range = calculate_remaining_range(
        vehicle["battery_capacity"],
        vehicle["soc"],
        vehicle["energy_consumption"],
    )
    print(f"Vehicle {i}: {remaining_range:.2f} km")
